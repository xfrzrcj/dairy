# 乐观锁悲观锁

## 乐观锁
### 定义：
假定最好的情况，认为在读取数据期间，数据不会被改动，所以不上锁，但在更新时会检查数据是被人更新过，可以使用版本号或CAS算法实现。
### CAS算法
即compare and swap(比较与交换)，著名的无锁算法。涉及3个操作：
* 需要读写的内存值V
* 进行比较值A
* 拟写入值B
当且仅当A和V相等时,CAS通过原子方式用B来更新V的值，否则不执行任何操作。一般情况下是自旋操作，即不断重试。
###问题
* ABA问题

如果变量V初次读取的时候值是A,在比较之前数据被更改为B，在比较时又更新回A，这时我们没有办法知道数据已经被修改过。
* 循环开销时间大

自旋CAS一直在循环执行，对cpu的开销十分大。
* 只能共享一个变量的原子操作

CAS只对单个共享变量有效，设计多个操作时无效。对java来说，从jdk1.5开始，提供AtomicReference类可以把多个变量放在同一个对象里来进行CAS操作。

## 悲观锁
定义：假设最坏的情况，认为拿数据时其他人会修改，所以拿数据时会上锁，这样别人拿数据时就需要等待直到释放锁。传统关系型数据库也用到很多悲观锁的机制，如表锁，行锁，读锁，写锁。java中synchronized和ReentrantLock等独占锁就是悲观锁的思想体现。

[参考](https://blog.csdn.net/qq_34337272/article/details/81072874)
